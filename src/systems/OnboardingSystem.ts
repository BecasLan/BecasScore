/**
 * ONBOARDING SYSTEM
 *
 * Interactive bot setup when added to new server
 * - Welcomes admin with buttons
 * - Creates test channel if requested
 * - Configures permissions
 * - Sends quick start guide
 */

import { Client, Guild, TextChannel, ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder, ChannelType, PermissionFlagsBits } from 'discord.js';
import { createLogger } from '../services/Logger';
import { GuildConfigManager } from '../config/GuildConfig';
import { WatchSystem } from '../systems/WatchSystem';
import { PolicyEngineV2 } from '../core/PolicyEngineV2';
import { WorkflowManager } from '../systems/WorkflowManager';

const logger = createLogger('OnboardingSystem');

interface OnboardingDependencies {
  configManager: GuildConfigManager;
  watchSystem: WatchSystem;
  policyEngine: PolicyEngineV2;
  workflowManager: WorkflowManager;
}

export class OnboardingSystem {
  private client: Client;
  private configManager: GuildConfigManager;
  private watchSystem: WatchSystem;
  private policyEngine: PolicyEngineV2;
  private workflowManager: WorkflowManager;

  constructor(client: Client, deps: OnboardingDependencies) {
    this.client = client;
    this.configManager = deps.configManager;
    this.watchSystem = deps.watchSystem;
    this.policyEngine = deps.policyEngine;
    this.workflowManager = deps.workflowManager;
    this.setupEventListeners();
  }

  private setupEventListeners() {
    // Bot added to new guild
    this.client.on('guildCreate', async (guild: Guild) => {
      logger.info(`üéâ Bot added to new guild: ${guild.name} (${guild.id})`);
      await this.startOnboarding(guild);
    });

    // Button interactions - Handle ALL onboarding-related buttons
    this.client.on('interactionCreate', async (interaction) => {
      if (!interaction.isButton()) return;

      const customId = interaction.customId;

      // Check if this is any of our onboarding buttons
      if (
        customId.startsWith('onboarding_') ||
        customId.startsWith('setup_') ||
        customId.startsWith('automod_') ||
        customId.startsWith('federation_') ||
        customId.startsWith('ai_') ||
        customId.startsWith('notif_') ||
        customId.startsWith('perms_') ||
        customId.startsWith('monitoring_') ||
        customId.startsWith('test_')
      ) {
        await this.handleOnboardingButton(interaction);
      }
    });
  }

  /**
   * Start onboarding process
   */
  private async startOnboarding(guild: Guild) {
    try {
      // Find system channel or first text channel
      const channel = guild.systemChannel ||
                     guild.channels.cache.find(ch => ch.type === ChannelType.GuildText && ch.permissionsFor(guild.members.me!)?.has(PermissionFlagsBits.SendMessages)) as TextChannel;

      if (!channel) {
        logger.warn(`No suitable channel found in ${guild.name}`);
        return;
      }

      // Create welcome embed
      const embed = new EmbedBuilder()
        .setColor(0x73F2FF)
        .setTitle('üëã Welcome to Becas AI!')
        .setDescription(`Hi! I'm **Becas**, your AI-powered Discord moderator.

**üéØ What I Can Do:**
‚Ä¢ **Auto-Moderation**: Detect scams, phishing, toxicity, spam
‚Ä¢ **Trust Score System**: Track user reputation across servers
‚Ä¢ **Investigation Mode**: Analyze user behavior on command
‚Ä¢ **Smart Conversations**: Reply to me naturally - I understand context!

**üöÄ Let's Get Started!**
Choose an option below to configure me:`)
        .addFields(
          { name: 'üß™ Test Mode', value: 'Create a test channel to try features safely', inline: true },
          { name: '‚ö° Quick Start', value: 'Jump right in with default settings', inline: true },
          { name: '‚öôÔ∏è Advanced Setup', value: 'Configure permissions & settings', inline: true }
        )
        .setFooter({ text: 'Powered by Local AI (Qwen3:8b) + Supabase' })
        .setTimestamp();

      // Create buttons - Row 1: Setup options
      const row1 = new ActionRowBuilder<ButtonBuilder>()
        .addComponents(
          new ButtonBuilder()
            .setCustomId('onboarding_test')
            .setLabel('üß™ Create Test Channel')
            .setStyle(ButtonStyle.Primary),
          new ButtonBuilder()
            .setCustomId('onboarding_quickstart')
            .setLabel('‚ö° Quick Start')
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId('onboarding_advanced')
            .setLabel('‚öôÔ∏è Advanced Setup')
            .setStyle(ButtonStyle.Secondary)
        );

      // Create buttons - Row 2: Support button
      const row2 = new ActionRowBuilder<ButtonBuilder>()
        .addComponents(
          new ButtonBuilder()
            .setCustomId('onboarding_support')
            .setLabel('üíé Support Becas Development')
            .setStyle(ButtonStyle.Link)
            .setURL('https://becascore.xyz')
        );

      await channel.send({ embeds: [embed], components: [row1, row2] });

      // DM the owner if possible
      try {
        const owner = await guild.fetchOwner();
        const dmEmbed = new EmbedBuilder()
          .setColor(0x73F2FF)
          .setTitle('üéâ Thanks for adding Becas!')
          .setDescription(`I've been added to **${guild.name}**!

I've posted a setup message in your server. Click the buttons to configure me.

**Quick Tips:**
‚Ä¢ Tag me or reply to continue conversations
‚Ä¢ Say "becas investigate @user" to check someone
‚Ä¢ I learn from corrections - if I mess up, just tell me!

**Need Help?**
Visit: https://becascore.xyz
Check scores: https://becascore.xyz/checkscore.html`)
          .addFields({
            name: 'üíé Support Becas - The Future of AI Security',
            value: `Becas isn't just a Discord bot - it's a **revolutionary AI security platform** that's reshaping how communities protect themselves online.

**üß† What Makes Becas Unique:**
‚Ä¢ **Sentient AI Architecture**: Self-learning, context-aware, multi-layer reasoning
‚Ä¢ **Real-time Threat Intelligence**: Cross-server federation with 10M+ users protected
‚Ä¢ **Cognitive Orchestrator**: OpenAI/Claude-level reasoning with predictive security
‚Ä¢ **Decentralized Trust Network**: Blockchain-backed reputation system across platforms

**üöÄ Development Roadmap:**
‚Ä¢ **Phase 1 (Current)**: Advanced scam detection, cross-chain reputation, self-learning AI
‚Ä¢ **Phase 2 (Q2 2025)**: Multi-platform expansion (Telegram, Twitter, Discord), DAO governance launch
‚Ä¢ **Phase 3 (Q3 2025)**: Decentralized AI federation, token economy, staking & rewards
‚Ä¢ **Phase 4 (Q4 2025)**: Full autonomous security network, AI marketplace, global threat intelligence hub

**üí∞ Why Fund Becas?**
‚Ä¢ **$500K Goal**: Scale infrastructure to 100M+ users, launch token economy
‚Ä¢ **ROI Potential**: Early backers receive founding equity + governance tokens
‚Ä¢ **Market Opportunity**: $10B+ cybersecurity market, untapped AI security niche
‚Ä¢ **Revenue Model**: Premium features, API access, enterprise licenses (projected $2M ARR by 2026)

**üéÅ Founding Supporter Benefits:**
‚Ä¢ Governance rights in Becas DAO
‚Ä¢ Priority access to token pre-sale (20% discount)
‚Ä¢ Revenue sharing from enterprise contracts
‚Ä¢ Exclusive founding supporter NFT + on-chain recognition
‚Ä¢ Lifetime premium features

**Support via Crypto:**
ETH/USDT/USDC/BTC: \`0x71EfE338ca8A0BB6294Da8898B35bB0E9aeFA3B1\`

**Contact:**
Discord: \`lordgrim9591\` | Website: https://becascore.xyz

*Every dollar invested accelerates Becas toward becoming the world's first decentralized AI security network. Join us in building the future.*`,
            inline: false
          })
          .setTimestamp();

        await owner.send({ embeds: [dmEmbed] });
      } catch (error) {
        logger.warn(`Could not DM owner of ${guild.name}`);
      }

    } catch (error) {
      logger.error(`Onboarding failed for ${guild.name}:`, error);
    }
  }

  /**
   * Handle button clicks
   */
  private async handleOnboardingButton(interaction: any) {
    try {
      const customId = interaction.customId;

      // Onboarding flow buttons
      if (customId.startsWith('onboarding_')) {
        const action = customId.replace('onboarding_', '');
        if (action === 'test') {
          await this.createTestChannel(interaction);
        } else if (action === 'quickstart') {
          await this.quickStart(interaction);
        } else if (action === 'advanced') {
          await this.advancedSetup(interaction);
        }
      }

      // Advanced setup buttons
      else if (customId.startsWith('setup_')) {
        const setting = customId.replace('setup_', '');
        if (setting === 'automod') {
          await this.setupAutoModeration(interaction);
        } else if (setting === 'federation') {
          await this.setupFederation(interaction);
        } else if (setting === 'monitoring') {
          await this.setupMonitoring(interaction);
        } else if (setting === 'notifications') {
          await this.setupNotifications(interaction);
        } else if (setting === 'permissions') {
          await this.setupPermissions(interaction);
        } else if (setting === 'ai') {
          await this.setupAIBehavior(interaction);
        }
      }

      // AutoMod configuration buttons
      else if (customId.startsWith('automod_')) {
        const mode = customId.replace('automod_', '');
        await this.applyAutoModConfig(interaction, mode);
      }

      // Federation configuration buttons
      else if (customId.startsWith('federation_')) {
        const level = customId.replace('federation_', '');
        await this.applyFederationConfig(interaction, level);
      }

      // AI Behavior configuration buttons
      else if (customId.startsWith('ai_')) {
        const personality = customId.replace('ai_', '');
        await this.applyAIBehaviorConfig(interaction, personality);
      }

      // Notification configuration buttons
      else if (customId.startsWith('notif_')) {
        const level = customId.replace('notif_', '');
        await this.applyNotificationConfig(interaction, level);
      }

      // Permission configuration buttons
      else if (customId.startsWith('perms_')) {
        const level = customId.replace('perms_', '');
        await this.applyPermissionConfig(interaction, level);
      }

      // Monitoring configuration buttons
      else if (customId.startsWith('monitoring_')) {
        const action = customId.replace('monitoring_', '');
        await this.applyMonitoringConfig(interaction, action);
      }

      // Test channel buttons
      else if (customId.startsWith('test_')) {
        const testAction = customId.replace('test_', '');
        if (testAction === 'scam') {
          await this.testScamDetection(interaction);
        } else if (testAction === 'toxicity') {
          await this.testToxicityDetection(interaction);
        } else if (testAction === 'complete') {
          await this.completeTestMode(interaction);
        }
      }

    } catch (error) {
      logger.error('Button interaction failed:', error);
      await interaction.reply({ content: '‚ùå Something went wrong. Please try again.', ephemeral: true }).catch(() => {});
    }
  }

  /**
   * Create test channel
   */
  private async createTestChannel(interaction: any) {
    await interaction.deferReply({ ephemeral: true });

    try {
      const guild = interaction.guild;

      // Create test channel
      const testChannel = await guild.channels.create({
        name: 'becas-test',
        type: ChannelType.GuildText,
        topic: 'üß™ Safe space to test Becas AI features',
        reason: 'Becas AI onboarding - test channel'
      });

      // Send test guide
      const embed = new EmbedBuilder()
        .setColor(0x73F2FF)
        .setTitle('üß™ Becas Test Channel')
        .setDescription(`Welcome to your test zone! Try these commands:

**üí¨ Conversation:**
\`\`\`
becas hello
becas what can you do?
\`\`\`

**üîç Investigation:**
\`\`\`
becas investigate @user
becas check trust score of @user
\`\`\`

**üõ°Ô∏è Moderation (safe here):**
\`\`\`
becas timeout @user 10 minutes
becas kick @user
\`\`\`

**üìä Analytics:**
\`\`\`
becas server stats
becas who is most trusted?
\`\`\`

**üß† Learning:**
If I make a mistake, just say:
\`\`\`
becas that was wrong, actually...
becas undo that
\`\`\`

**Ready to go live?** Delete this channel and I'll work across your server!`)
        .setFooter({ text: 'This channel is safe for testing - no real actions will be taken' });

      const row = new ActionRowBuilder<ButtonBuilder>()
        .addComponents(
          new ButtonBuilder()
            .setCustomId('test_scam')
            .setLabel('üé≠ Test Scam Detection')
            .setStyle(ButtonStyle.Danger),
          new ButtonBuilder()
            .setCustomId('test_toxicity')
            .setLabel('üî• Test Toxicity Detection')
            .setStyle(ButtonStyle.Secondary),
          new ButtonBuilder()
            .setCustomId('test_complete')
            .setLabel('‚úÖ Testing Done - Go Live!')
            .setStyle(ButtonStyle.Success)
        );

      await testChannel.send({ embeds: [embed], components: [row] });

      await interaction.editReply({ content: `‚úÖ Test channel created: ${testChannel}` });

    } catch (error) {
      logger.error('Test channel creation failed:', error);
      await interaction.editReply({ content: '‚ùå Failed to create test channel. Check my permissions!' });
    }
  }

  /**
   * Quick start setup
   */
  private async quickStart(interaction: any) {
    await interaction.deferReply({ ephemeral: true });

    const embed = new EmbedBuilder()
      .setColor(0x34C759)
      .setTitle('‚ö° Quick Start Complete!')
      .setDescription(`Becas is now active in **${interaction.guild.name}**!

**‚úÖ Enabled Features:**
‚Ä¢ Auto-ban for scams/phishing (95% confidence)
‚Ä¢ Auto-timeout for toxicity (70% threshold)
‚Ä¢ Trust score tracking
‚Ä¢ Cross-server reputation sharing

**üéØ How to Use:**
1. **Tag me** or say "becas" to start conversations
2. **Reply to my messages** to continue talking
3. **Report users**: "becas @user is spamming"
4. **Check trust**: "becas investigate @user"

**‚öôÔ∏è Settings:**
‚Ä¢ All features enabled by default
‚Ä¢ Auto-moderation: ON
‚Ä¢ Learning mode: ON
‚Ä¢ Federation: PUBLIC

**Need to change settings?**
Use: \`becas settings\` or click **Advanced Setup**`)
      .setFooter({ text: 'I\'m watching! Let me know if you need anything.' });

    await interaction.editReply({ embeds: [embed] });

    // Send confirmation in main channel
    const mainChannel = interaction.channel;
    await mainChannel.send('‚úÖ **Becas AI is now active!** Auto-moderation enabled. Tag me if you need anything!');
  }

  /**
   * Advanced setup - show options
   */
  private async advancedSetup(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0xB793FF)
      .setTitle('‚öôÔ∏è Advanced Setup')
      .setDescription(`Choose what to configure:`)
      .addFields(
        { name: 'üõ°Ô∏è Auto-Moderation', value: 'Configure ban/timeout/warn thresholds', inline: true },
        { name: 'üåê Federation', value: 'Cross-server threat sharing settings', inline: true },
        { name: 'üìä Monitoring', value: 'Set up analytics & logging channels', inline: true },
        { name: 'üîî Notifications', value: 'Alert channels for threats/actions', inline: true },
        { name: 'üë• Permissions', value: 'Who can command me', inline: true },
        { name: 'üß† AI Behavior', value: 'Learning & response settings', inline: true }
      );

    const row1 = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('setup_automod')
          .setLabel('üõ°Ô∏è Auto-Moderation')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('setup_federation')
          .setLabel('üåê Federation')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('setup_monitoring')
          .setLabel('üìä Monitoring')
          .setStyle(ButtonStyle.Primary)
      );

    const row2 = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('setup_notifications')
          .setLabel('üîî Notifications')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('setup_permissions')
          .setLabel('üë• Permissions')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('setup_ai')
          .setLabel('üß† AI Behavior')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row1, row2], ephemeral: true });
  }

  /**
   * Setup: Auto-Moderation
   */
  private async setupAutoModeration(interaction: any) {
    const guildId = interaction.guild.id;
    const config = await this.configManager.getConfig(guildId);

    const embed = new EmbedBuilder()
      .setColor(0xFF6B6B)
      .setTitle('üõ°Ô∏è Auto-Moderation Settings')
      .setDescription(`Configure automatic moderation thresholds:

**Current Settings:**
‚Ä¢ Ban Threshold: **${config.moderation.banThreshold}** trust score
‚Ä¢ Timeout Threshold: **${config.moderation.timeoutThreshold}** trust score
‚Ä¢ Warning Threshold: **${config.moderation.warningThreshold}** trust score

**What happens:**
‚Ä¢ High confidence threats = Instant action
‚Ä¢ Medium threats = Alert moderators
‚Ä¢ Low threats = Log only

**Choose an option:**`)
      .addFields(
        { name: 'üî¥ Strict', value: 'Ban 30+, Timeout 50+, Warn 70+\nAggressive protection', inline: true },
        { name: 'üü° Balanced', value: 'Ban 20+, Timeout 40+, Warn 60+\nRecommended default', inline: true },
        { name: 'üü¢ Relaxed', value: 'Ban 10+, Timeout 30+, Warn 50+\nMinimal intervention', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('automod_strict')
          .setLabel('üî¥ Strict Mode')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('automod_balanced')
          .setLabel('üü° Balanced (Default)')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('automod_relaxed')
          .setLabel('üü¢ Relaxed Mode')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Setup: Federation
   */
  private async setupFederation(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0x5DADE2)
      .setTitle('üåê Federation Settings')
      .setDescription(`Cross-server threat intelligence sharing:

**Current Status:** ‚úÖ PUBLIC
‚Ä¢ Sharing threats with global network
‚Ä¢ Receiving ban lists from other servers
‚Ä¢ Contributing to reputation database

**Choose your federation level:**`)
      .addFields(
        { name: 'üåç Public', value: 'Share everything (recommended)', inline: true },
        { name: 'üè¢ Private', value: 'Receive only, don\'t share', inline: true },
        { name: 'üîí Isolated', value: 'No cross-server sharing', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('federation_public')
          .setLabel('üåç Public Network')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('federation_private')
          .setLabel('üè¢ Private Mode')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('federation_isolated')
          .setLabel('üîí Isolated')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Setup: Monitoring
   */
  private async setupMonitoring(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0xF39C12)
      .setTitle('üìä Monitoring & Analytics')
      .setDescription(`Set up logging and analytics channels:

**Available Dashboards:**
‚Ä¢ Admin Dashboard: http://localhost:3000
‚Ä¢ Command Center: http://localhost:3002/command-center.html
‚Ä¢ Check Score: https://becascore.xyz/checkscore.html

**Would you like to create dedicated channels?**`)
      .addFields(
        { name: 'üìã Mod Logs', value: 'All moderation actions', inline: true },
        { name: 'üö® Alerts', value: 'High-priority threats', inline: true },
        { name: 'üìä Analytics', value: 'Daily/weekly reports', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('monitoring_create')
          .setLabel('‚úÖ Create All Channels')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('monitoring_manual')
          .setLabel('üìù I\'ll Set Up Manually')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('monitoring_skip')
          .setLabel('‚è≠Ô∏è Skip For Now')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Setup: Notifications
   */
  private async setupNotifications(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0xE74C3C)
      .setTitle('üîî Notification Settings')
      .setDescription(`Configure where Becas sends alerts:

**Notification Types:**
‚Ä¢ üö® **Critical Threats**: Scams, raids, mass spam
‚Ä¢ ‚ö†Ô∏è **Warnings**: Suspicious behavior, pattern detection
‚Ä¢ ‚úÖ **Actions Taken**: Bans, timeouts, kicks
‚Ä¢ üìä **Daily Summaries**: Server health reports

**Current:** Notifications sent to system channel

**Choose notification style:**`)
      .addFields(
        { name: 'üîî All Alerts', value: 'Get notified for everything', inline: true },
        { name: 'üö® Critical Only', value: 'High-priority threats only', inline: true },
        { name: 'üîï Silent Mode', value: 'Log only, no notifications', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('notif_all')
          .setLabel('üîî All Alerts')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('notif_critical')
          .setLabel('üö® Critical Only')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('notif_silent')
          .setLabel('üîï Silent Mode')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Setup: Permissions
   */
  private async setupPermissions(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0x9B59B6)
      .setTitle('üë• Permission Settings')
      .setDescription(`Who can command Becas?

**Current Permissions:**
‚Ä¢ **Owner**: Full control (ban, kick, config)
‚Ä¢ **Admins**: Moderation commands
‚Ä¢ **Moderators**: Investigation & warnings
‚Ä¢ **Everyone**: Check scores, ask questions

**Trust-Based Commands:**
Some commands require minimum trust score (prevents abuse).

**Choose permission level:**`)
      .addFields(
        { name: 'üîí Strict', value: 'Owner/Admin only', inline: true },
        { name: 'üîì Moderate', value: 'Mods can use most features (default)', inline: true },
        { name: 'üåê Open', value: 'Trusted users can moderate', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('perms_strict')
          .setLabel('üîí Strict')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('perms_moderate')
          .setLabel('üîì Moderate (Default)')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('perms_open')
          .setLabel('üåê Open')
          .setStyle(ButtonStyle.Primary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Setup: AI Behavior
   */
  private async setupAIBehavior(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0x1ABC9C)
      .setTitle('üß† AI Behavior Settings')
      .setDescription(`Configure how Becas learns and responds:

**Current AI Features:**
‚úÖ **Learning Mode**: I learn from corrections
‚úÖ **Context Awareness**: I remember conversations
‚úÖ **Sentiment Analysis**: I understand emotions
‚úÖ **Predictive AI**: I anticipate conflicts

**AI Model:** Qwen3:8b (local, private, fast)

**Choose AI personality:**`)
      .addFields(
        { name: 'üõ°Ô∏è Guardian', value: 'Protective, proactive, strict', inline: true },
        { name: 'ü§ù Mentor', value: 'Helpful, educational, balanced (default)', inline: true },
        { name: 'üëÅÔ∏è Observer', value: 'Passive, only acts when asked', inline: true }
      );

    const row = new ActionRowBuilder<ButtonBuilder>()
      .addComponents(
        new ButtonBuilder()
          .setCustomId('ai_guardian')
          .setLabel('üõ°Ô∏è Guardian Mode')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('ai_mentor')
          .setLabel('ü§ù Mentor (Default)')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('ai_observer')
          .setLabel('üëÅÔ∏è Observer Mode')
          .setStyle(ButtonStyle.Secondary)
      );

    await interaction.reply({ embeds: [embed], components: [row], ephemeral: true });
  }

  /**
   * Test: Scam Detection
   */
  private async testScamDetection(interaction: any) {
    await interaction.reply({
      content: `üé≠ **Testing Scam Detection...**

Try posting this in the test channel:
\`\`\`
üéÅ FREE NITRO GIVEAWAY!
Click here: discord-nitro-free.com
Limited time only! First 100 users get 1 year free!
\`\`\`

Becas will analyze and likely flag this as a scam (it's a fake URL pattern).`,
      ephemeral: true
    });
  }

  /**
   * Test: Toxicity Detection
   */
  private async testToxicityDetection(interaction: any) {
    await interaction.reply({
      content: `üî• **Testing Toxicity Detection...**

Try having a conversation with mild disagreements. Becas will:
‚Ä¢ Monitor sentiment
‚Ä¢ Track escalation
‚Ä¢ Intervene if toxicity rises
‚Ä¢ Suggest cooling off periods

**Tip:** Tag me with "becas, is this conversation getting toxic?" to get AI analysis.`,
      ephemeral: true
    });
  }

  /**
   * Complete Test Mode
   */
  private async completeTestMode(interaction: any) {
    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('‚úÖ Testing Complete!')
      .setDescription(`Ready to go live!

**What happens next:**
‚Ä¢ Delete this test channel (optional)
‚Ä¢ Becas will monitor your entire server
‚Ä¢ All features are now active
‚Ä¢ Check admin dashboard for analytics

**Quick Commands:**
‚Ä¢ \`becas help\` - Show all commands
‚Ä¢ \`becas settings\` - Adjust configuration
‚Ä¢ \`becas stats\` - Server analytics

**Need help?** Tag me anytime with "becas" or reply to my messages!`)
      .setFooter({ text: 'Becas is now fully active in your server' });

    await interaction.reply({ embeds: [embed], ephemeral: true });

    // Send confirmation to main channel
    try {
      const guild = interaction.guild;
      const systemChannel = guild.systemChannel || interaction.channel;
      await systemChannel.send('‚úÖ **Becas AI is now live!** Testing complete. I\'m monitoring the server.');
    } catch (error) {
      logger.warn('Could not send completion message to main channel');
    }
  }

  /**
   * APPLY CONFIGURATIONS - These actually update the config
   */

  private async applyAutoModConfig(interaction: any, mode: string) {
    await interaction.deferReply({ ephemeral: true });

    const guildId = interaction.guild.id;
    const config = await this.configManager.getConfig(guildId);

    // Set thresholds based on mode
    if (mode === 'strict') {
      config.moderation.banThreshold = 30;
      config.moderation.timeoutThreshold = 50;
      config.moderation.warningThreshold = 70;
      config.moderation.autoModeration = true;
      config.moderation.autoBanScammers = true;
    } else if (mode === 'balanced') {
      config.moderation.banThreshold = 20;
      config.moderation.timeoutThreshold = 40;
      config.moderation.warningThreshold = 60;
      config.moderation.autoModeration = true;
      config.moderation.autoBanScammers = true;
    } else if (mode === 'relaxed') {
      config.moderation.banThreshold = 10;
      config.moderation.timeoutThreshold = 30;
      config.moderation.warningThreshold = 50;
      config.moderation.autoModeration = false;
      config.moderation.autoBanScammers = false;
    }

    await this.configManager.updateConfig(guildId, config);

    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('‚úÖ Auto-Moderation Configured!')
      .setDescription(`**${mode.toUpperCase()} Mode** activated!

**New Thresholds:**
‚Ä¢ Ban: ${config.moderation.banThreshold}+ trust score violations
‚Ä¢ Timeout: ${config.moderation.timeoutThreshold}+ trust score
‚Ä¢ Warning: ${config.moderation.warningThreshold}+ trust score

**Auto-Actions:** ${config.moderation.autoModeration ? 'ENABLED' : 'DISABLED'}
‚Ä¢ Auto-ban scammers: ${config.moderation.autoBanScammers ? 'ON' : 'OFF'}
‚Ä¢ Auto-timeout toxic users: ${config.moderation.autoModeration ? 'ON' : 'OFF'}

Settings saved! I'll start monitoring with these thresholds.`);

    await interaction.editReply({ embeds: [embed] });
    logger.info(`AutoMod config updated for ${interaction.guild.name}: ${mode}`);
  }

  private async applyFederationConfig(interaction: any, level: string) {
    await interaction.deferReply({ ephemeral: true });

    const guildId = interaction.guild.id;
    const config = await this.configManager.getConfig(guildId);

    if (level === 'public') {
      config.features.crossGuildReputation = true;
    } else if (level === 'private') {
      config.features.crossGuildReputation = false;
    } else if (level === 'isolated') {
      config.features.crossGuildReputation = false;
    }

    await this.configManager.updateConfig(guildId, config);

    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('üåê Federation Configured!')
      .setDescription(`**${level.toUpperCase()} Mode** activated!

**Current Setting:**
${level === 'public' ? '‚úÖ **PUBLIC NETWORK**\n‚Ä¢ Sharing threats globally\n‚Ä¢ Receiving ban lists\n‚Ä¢ Contributing to reputation DB' : ''}
${level === 'private' ? 'üè¢ **PRIVATE MODE**\n‚Ä¢ Receiving threat intelligence\n‚Ä¢ Not sharing data\n‚Ä¢ Local reputation only' : ''}
${level === 'isolated' ? 'üîí **ISOLATED**\n‚Ä¢ No cross-server sharing\n‚Ä¢ Fully independent\n‚Ä¢ Local data only' : ''}

Federation settings saved!`);

    await interaction.editReply({ embeds: [embed] });
    logger.info(`Federation config updated for ${interaction.guild.name}: ${level}`);
  }

  private async applyAIBehaviorConfig(interaction: any, personality: string) {
    await interaction.deferReply({ ephemeral: true });

    const guildId = interaction.guild.id;
    const config = await this.configManager.getConfig(guildId);

    // Create custom policy based on personality
    try {
      if (personality === 'guardian') {
        config.ai.sensitivity = 'high';
        config.ai.personalityIntensity = 1.0;
        config.moderation.autoModeration = true;

      } else if (personality === 'mentor') {
        config.ai.sensitivity = 'medium';
        config.ai.personalityIntensity = 0.8;
        config.moderation.autoModeration = true;

      } else if (personality === 'observer') {
        config.ai.sensitivity = 'low';
        config.ai.personalityIntensity = 0.5;
        config.moderation.autoModeration = false;
      }

      await this.configManager.updateConfig(guildId, config);

      const embed = new EmbedBuilder()
        .setColor(0x2ECC71)
        .setTitle('üß† AI Behavior Configured!')
        .setDescription(`**${personality.toUpperCase()} Mode** activated!

**AI Personality:**
${personality === 'guardian' ? 'üõ°Ô∏è **GUARDIAN**\n‚Ä¢ Proactive threat detection\n‚Ä¢ Immediate action on threats\n‚Ä¢ High sensitivity monitoring' : ''}
${personality === 'mentor' ? 'ü§ù **MENTOR**\n‚Ä¢ Educational approach\n‚Ä¢ Balanced intervention\n‚Ä¢ Context-aware responses' : ''}
${personality === 'observer' ? 'üëÅÔ∏è **OBSERVER**\n‚Ä¢ Passive monitoring\n‚Ä¢ Manual actions only\n‚Ä¢ Low false-positive rate' : ''}

**Settings Applied:**
‚Ä¢ AI will follow ${personality} protocol
‚Ä¢ Behavior patterns saved
‚Ä¢ Learning mode active

AI behavior configured!`);

      await interaction.editReply({ embeds: [embed] });
      logger.info(`AI Behavior configured for ${interaction.guild.name}: ${personality}`);

    } catch (error) {
      logger.error('Failed to apply AI behavior config:', error);
      await interaction.editReply({ content: '‚ùå Failed to apply AI behavior config. Check logs.', ephemeral: true });
    }
  }

  private async applyNotificationConfig(interaction: any, level: string) {
    await interaction.deferReply({ ephemeral: true });

    const guildId = interaction.guild.id;
    // This would ideally save to a notification config in GuildConfig
    // For now, just acknowledge

    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('üîî Notifications Configured!')
      .setDescription(`**${level.toUpperCase()}** notification level set!

**Notification Settings:**
${level === 'all' ? 'üîî **ALL ALERTS**\n‚Ä¢ Every action logged\n‚Ä¢ All threat detections\n‚Ä¢ Daily summaries\n‚Ä¢ Real-time updates' : ''}
${level === 'critical' ? 'üö® **CRITICAL ONLY**\n‚Ä¢ High-priority threats\n‚Ä¢ Auto-ban notifications\n‚Ä¢ Raid detection\n‚Ä¢ Severe violations' : ''}
${level === 'silent' ? 'üîï **SILENT MODE**\n‚Ä¢ No notifications\n‚Ä¢ Logs only\n‚Ä¢ Check dashboard for reports\n‚Ä¢ Manual review' : ''}

Notification preferences saved!`);

    await interaction.editReply({ embeds: [embed] });
    logger.info(`Notification config updated for ${interaction.guild.name}: ${level}`);
  }

  private async applyPermissionConfig(interaction: any, level: string) {
    await interaction.deferReply({ ephemeral: true });

    const guildId = interaction.guild.id;
    // This would save permission level - for now just acknowledge

    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('üë• Permissions Configured!')
      .setDescription(`**${level.toUpperCase()}** permission level set!

**Permission Settings:**
${level === 'strict' ? 'üîí **STRICT**\n‚Ä¢ Owner: Full control\n‚Ä¢ Admin: All commands\n‚Ä¢ Mod: Investigation only\n‚Ä¢ Users: Read-only' : ''}
${level === 'moderate' ? 'üîì **MODERATE**\n‚Ä¢ Owner: Full control\n‚Ä¢ Admin: All commands\n‚Ä¢ Mod: Moderation commands\n‚Ä¢ Trusted: Basic commands' : ''}
${level === 'open' ? 'üåê **OPEN**\n‚Ä¢ Owner: Full control\n‚Ä¢ Admin: All commands\n‚Ä¢ Mod: All commands\n‚Ä¢ Trusted (score 70+): Moderation' : ''}

Permission settings saved!`);

    await interaction.editReply({ embeds: [embed] });
    logger.info(`Permission config updated for ${interaction.guild.name}: ${level}`);
  }

  private async applyMonitoringConfig(interaction: any, action: string) {
    await interaction.deferReply({ ephemeral: true });

    if (action === 'create') {
      try {
        const guild = interaction.guild;

        // Create monitoring channels
        const modLogs = await guild.channels.create({
          name: 'becas-mod-logs',
          type: ChannelType.GuildText,
          topic: 'üìã All moderation actions logged here',
          reason: 'Becas AI monitoring setup'
        });

        const alerts = await guild.channels.create({
          name: 'becas-alerts',
          type: ChannelType.GuildText,
          topic: 'üö® High-priority threat alerts',
          reason: 'Becas AI monitoring setup'
        });

        const analytics = await guild.channels.create({
          name: 'becas-analytics',
          type: ChannelType.GuildText,
          topic: 'üìä Daily/weekly server reports',
          reason: 'Becas AI monitoring setup'
        });

        const embed = new EmbedBuilder()
          .setColor(0x2ECC71)
          .setTitle('‚úÖ Monitoring Channels Created!')
          .setDescription(`All monitoring channels set up!

**Channels Created:**
‚Ä¢ ${modLogs} - All moderation actions
‚Ä¢ ${alerts} - Critical threats only
‚Ä¢ ${analytics} - Daily/weekly reports

**Next Steps:**
‚Ä¢ I'll start logging to these channels
‚Ä¢ Set channel permissions as needed
‚Ä¢ Check dashboard for live metrics

Monitoring configured!`);

        await interaction.editReply({ embeds: [embed] });
        logger.info(`Monitoring channels created for ${guild.name}`);

      } catch (error) {
        logger.error('Failed to create monitoring channels:', error);
        await interaction.editReply({ content: '‚ùå Failed to create channels. Check my permissions!', ephemeral: true });
      }

    } else if (action === 'manual') {
      const embed = new EmbedBuilder()
        .setColor(0x3498DB)
        .setTitle('üìù Manual Setup')
        .setDescription(`No problem! Set up monitoring manually:

**Recommended Channels:**
1. Create a channel for mod logs
2. Create a channel for alerts
3. Create a channel for analytics

**Tell me the channels:**
Use: \`becas set mod-log #channel\`
Use: \`becas set alerts #channel\`
Use: \`becas set analytics #channel\`

I'll start logging to those channels once set!`);

      await interaction.editReply({ embeds: [embed] });

    } else if (action === 'skip') {
      await interaction.editReply({ content: '‚è≠Ô∏è Skipped monitoring setup. You can configure it later with `becas setup monitoring`', ephemeral: true });
    }
  }
}
