import { Pool, QueryResult } from 'pg';
import logger from '../utils/logger';
import { ParsedQuery } from './QueryParser';

/**
 * QueryExecutor
 *
 * Safely executes SQL queries generated by QueryParser.
 *
 * Safety Features:
 * - Query timeout (10 seconds max)
 * - Result limit (1000 rows max)
 * - Error handling
 * - Query logging (audit trail)
 * - Query caching (repeated questions)
 * - Performance monitoring
 */

export interface ExecutionResult {
  success: boolean;
  rows: any[];
  rowCount: number;
  executionTime: number;
  cached: boolean;
  error?: string;
  query?: string;
}

export interface QueryLog {
  id: string;
  serverId: string;
  userId: string;
  question: string;
  sql: string;
  success: boolean;
  rowCount: number;
  executionTime: number;
  error?: string;
  createdAt: Date;
}

export class QueryExecutor {
  private db: Pool;
  private cache: Map<string, { result: ExecutionResult; timestamp: number }> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private readonly QUERY_TIMEOUT = 10000; // 10 seconds
  private readonly MAX_ROWS = 1000;

  constructor(db: Pool) {
    this.db = db;
  }

  /**
   * Initialize database tables
   */
  async initialize(): Promise<void> {
    await this.createTables();
    this.startCacheCleanup();
    logger.info('QueryExecutor initialized');
  }

  /**
   * Create query log table
   */
  private async createTables(): Promise<void> {
    const createQueryLogTable = `
      CREATE TABLE IF NOT EXISTS query_logs (
        id VARCHAR(255) PRIMARY KEY,
        server_id VARCHAR(255) NOT NULL,
        user_id VARCHAR(255) NOT NULL,
        question TEXT NOT NULL,
        sql TEXT NOT NULL,
        success BOOLEAN NOT NULL,
        row_count INTEGER,
        execution_time INTEGER,
        error TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        INDEX idx_server_query (server_id, created_at)
      );
    `;

    await this.db.query(createQueryLogTable);
    logger.info('Query log table created');
  }

  /**
   * Execute SQL query
   */
  async executeQuery(
    parsedQuery: ParsedQuery,
    serverId: string,
    userId: string,
    question: string
  ): Promise<ExecutionResult> {
    const startTime = Date.now();

    try {
      // Check cache first
      const cacheKey = this.getCacheKey(parsedQuery.sql, serverId);
      const cached = this.getFromCache(cacheKey);
      if (cached) {
        logger.info(`Cache hit for query: ${parsedQuery.intent}`);
        await this.logQuery(serverId, userId, question, parsedQuery.sql, true, cached.rowCount, cached.executionTime);
        return { ...cached, cached: true };
      }

      // Validate query safety
      if (!parsedQuery.safe) {
        const error = `Unsafe query: ${parsedQuery.warnings?.join(', ')}`;
        logger.warn(error);
        await this.logQuery(serverId, userId, question, parsedQuery.sql, false, 0, 0, error);
        return {
          success: false,
          rows: [],
          rowCount: 0,
          executionTime: 0,
          cached: false,
          error
        };
      }

      // Execute query with timeout
      logger.info(`Executing query: ${parsedQuery.sql}`);
      const result = await this.executeWithTimeout(parsedQuery.sql);

      const executionTime = Date.now() - startTime;
      const rowCount = result.rows.length;

      // Limit rows
      const limitedRows = result.rows.slice(0, this.MAX_ROWS);

      const executionResult: ExecutionResult = {
        success: true,
        rows: limitedRows,
        rowCount,
        executionTime,
        cached: false,
        query: parsedQuery.sql
      };

      // Cache result
      this.addToCache(cacheKey, executionResult);

      // Log query
      await this.logQuery(serverId, userId, question, parsedQuery.sql, true, rowCount, executionTime);

      logger.info(`Query executed successfully: ${rowCount} rows in ${executionTime}ms`);

      return executionResult;

    } catch (error) {
      const executionTime = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      logger.error('Query execution failed:', error);

      // Log failed query
      await this.logQuery(serverId, userId, question, parsedQuery.sql, false, 0, executionTime, errorMessage);

      return {
        success: false,
        rows: [],
        rowCount: 0,
        executionTime,
        cached: false,
        error: errorMessage,
        query: parsedQuery.sql
      };
    }
  }

  /**
   * Execute query with timeout
   */
  private async executeWithTimeout(sql: string): Promise<QueryResult> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Query timeout (exceeded 10 seconds)'));
      }, this.QUERY_TIMEOUT);

      this.db.query(sql)
        .then(result => {
          clearTimeout(timeout);
          resolve(result);
        })
        .catch(error => {
          clearTimeout(timeout);
          reject(error);
        });
    });
  }

  /**
   * Log query execution
   */
  private async logQuery(
    serverId: string,
    userId: string,
    question: string,
    sql: string,
    success: boolean,
    rowCount: number,
    executionTime: number,
    error?: string
  ): Promise<void> {
    try {
      const id = `query-${serverId}-${userId}-${Date.now()}`;

      const query = `
        INSERT INTO query_logs
        (id, server_id, user_id, question, sql, success, row_count, execution_time, error)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      `;

      await this.db.query(query, [
        id,
        serverId,
        userId,
        question,
        sql,
        success,
        rowCount,
        executionTime,
        error || null
      ]);

    } catch (logError) {
      logger.error('Failed to log query:', logError);
      // Don't throw - logging failure shouldn't break query execution
    }
  }

  /**
   * Get cached result
   */
  private getFromCache(key: string): ExecutionResult | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    // Check if expired
    const age = Date.now() - cached.timestamp;
    if (age > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.result;
  }

  /**
   * Add result to cache
   */
  private addToCache(key: string, result: ExecutionResult): void {
    this.cache.set(key, {
      result,
      timestamp: Date.now()
    });
  }

  /**
   * Generate cache key
   */
  private getCacheKey(sql: string, serverId: string): string {
    // Simple hash (in production, use crypto.createHash)
    return `${serverId}:${sql}`;
  }

  /**
   * Start cache cleanup job
   */
  private startCacheCleanup(): void {
    setInterval(() => {
      const now = Date.now();
      let removed = 0;

      for (const [key, value] of this.cache.entries()) {
        if (now - value.timestamp > this.CACHE_TTL) {
          this.cache.delete(key);
          removed++;
        }
      }

      if (removed > 0) {
        logger.debug(`Cache cleanup: removed ${removed} expired entries`);
      }
    }, 60000); // Clean every minute
  }

  /**
   * Get query logs for a server
   */
  async getQueryLogs(serverId: string, limit: number = 50): Promise<QueryLog[]> {
    const query = `
      SELECT * FROM query_logs
      WHERE server_id = $1
      ORDER BY created_at DESC
      LIMIT $2
    `;

    const result = await this.db.query(query, [serverId, limit]);

    return result.rows.map(row => ({
      id: row.id,
      serverId: row.server_id,
      userId: row.user_id,
      question: row.question,
      sql: row.sql,
      success: row.success,
      rowCount: row.row_count,
      executionTime: row.execution_time,
      error: row.error,
      createdAt: new Date(row.created_at)
    }));
  }

  /**
   * Get query statistics for a server
   */
  async getQueryStats(serverId: string, days: number = 7): Promise<{
    totalQueries: number;
    successfulQueries: number;
    failedQueries: number;
    avgExecutionTime: number;
    cacheHitRate: number;
    topQuestions: { question: string; count: number }[];
    slowQueries: { question: string; sql: string; executionTime: number }[];
  }> {
    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    // Total queries
    const totalResult = await this.db.query(
      'SELECT COUNT(*) as count FROM query_logs WHERE server_id = $1 AND created_at >= $2',
      [serverId, cutoffDate]
    );
    const totalQueries = parseInt(totalResult.rows[0].count);

    // Successful queries
    const successResult = await this.db.query(
      'SELECT COUNT(*) as count FROM query_logs WHERE server_id = $1 AND success = true AND created_at >= $2',
      [serverId, cutoffDate]
    );
    const successfulQueries = parseInt(successResult.rows[0].count);

    const failedQueries = totalQueries - successfulQueries;

    // Average execution time
    const avgTimeResult = await this.db.query(
      'SELECT AVG(execution_time) as avg FROM query_logs WHERE server_id = $1 AND success = true AND created_at >= $2',
      [serverId, cutoffDate]
    );
    const avgExecutionTime = parseFloat(avgTimeResult.rows[0].avg) || 0;

    // Cache hit rate (approximate - based on duplicate questions)
    const uniqueQuestionsResult = await this.db.query(
      'SELECT COUNT(DISTINCT question) as count FROM query_logs WHERE server_id = $1 AND created_at >= $2',
      [serverId, cutoffDate]
    );
    const uniqueQuestions = parseInt(uniqueQuestionsResult.rows[0].count);
    const cacheHitRate = totalQueries > 0 ? ((totalQueries - uniqueQuestions) / totalQueries) * 100 : 0;

    // Top questions
    const topQuestionsResult = await this.db.query(
      `SELECT question, COUNT(*) as count
       FROM query_logs
       WHERE server_id = $1 AND created_at >= $2
       GROUP BY question
       ORDER BY count DESC
       LIMIT 10`,
      [serverId, cutoffDate]
    );
    const topQuestions = topQuestionsResult.rows.map(row => ({
      question: row.question,
      count: parseInt(row.count)
    }));

    // Slow queries
    const slowQueriesResult = await this.db.query(
      `SELECT question, sql, execution_time
       FROM query_logs
       WHERE server_id = $1 AND success = true AND created_at >= $2
       ORDER BY execution_time DESC
       LIMIT 10`,
      [serverId, cutoffDate]
    );
    const slowQueries = slowQueriesResult.rows.map(row => ({
      question: row.question,
      sql: row.sql,
      executionTime: row.execution_time
    }));

    return {
      totalQueries,
      successfulQueries,
      failedQueries,
      avgExecutionTime: parseFloat(avgExecutionTime.toFixed(2)),
      cacheHitRate: parseFloat(cacheHitRate.toFixed(2)),
      topQuestions,
      slowQueries
    };
  }

  /**
   * Clear cache
   */
  clearCache(): void {
    this.cache.clear();
    logger.info('Query cache cleared');
  }

  /**
   * Get cache size
   */
  getCacheSize(): number {
    return this.cache.size;
  }
}

/**
 * Example usage:
 *
 * const executor = new QueryExecutor(db);
 * await executor.initialize();
 *
 * // Execute a parsed query
 * const parsedQuery = await queryParser.parseQuery('Bugün kaç ban yedi?', context);
 * const result = await executor.executeQuery(parsedQuery, serverId, userId, 'Bugün kaç ban yedi?');
 *
 * if (result.success) {
 *   console.log(`Query returned ${result.rowCount} rows in ${result.executionTime}ms`);
 *   console.log('Data:', result.rows);
 *   console.log('Cached:', result.cached);
 * } else {
 *   console.log('Query failed:', result.error);
 * }
 *
 * // Get query logs
 * const logs = await executor.getQueryLogs(serverId, 50);
 * console.log('Recent queries:', logs);
 *
 * // Get query statistics
 * const stats = await executor.getQueryStats(serverId, 7);
 * console.log('Query stats:', stats);
 */
